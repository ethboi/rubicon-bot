/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface RubiconMarketInterface extends utils.Interface {
  functions: {
    "AqueductAddress()": FunctionFragment;
    "AqueductDistributionLive()": FunctionFragment;
    "_best(address,address)": FunctionFragment;
    "_dust(address)": FunctionFragment;
    "_head()": FunctionFragment;
    "_near(uint256)": FunctionFragment;
    "_rank(uint256)": FunctionFragment;
    "_span(address,address)": FunctionFragment;
    "bump(bytes32)": FunctionFragment;
    "buy(uint256,uint256)": FunctionFragment;
    "buyAllAmount(address,uint256,address,uint256)": FunctionFragment;
    "buyEnabled()": FunctionFragment;
    "cancel(uint256)": FunctionFragment;
    "del_rank(uint256)": FunctionFragment;
    "dustId()": FunctionFragment;
    "getBestOffer(address,address)": FunctionFragment;
    "getBetterOffer(uint256)": FunctionFragment;
    "getBuyAmount(address,address,uint256)": FunctionFragment;
    "getFirstUnsortedOffer()": FunctionFragment;
    "getMinSell(address)": FunctionFragment;
    "getNextUnsortedOffer(uint256)": FunctionFragment;
    "getOffer(uint256)": FunctionFragment;
    "getOfferCount(address,address)": FunctionFragment;
    "getOwner(uint256)": FunctionFragment;
    "getPayAmount(address,address,uint256)": FunctionFragment;
    "getTime()": FunctionFragment;
    "getWorseOffer(uint256)": FunctionFragment;
    "initialize(bool,address)": FunctionFragment;
    "initialized()": FunctionFragment;
    "insert(uint256,uint256)": FunctionFragment;
    "isActive(uint256)": FunctionFragment;
    "isClosed()": FunctionFragment;
    "isOfferSorted(uint256)": FunctionFragment;
    "kill(bytes32)": FunctionFragment;
    "last_offer_id()": FunctionFragment;
    "make(address,address,uint128,uint128)": FunctionFragment;
    "matchingEnabled()": FunctionFragment;
    "offer(uint256,address,uint256,address,uint256)": FunctionFragment;
    "offer(uint256,address,uint256,address,uint256,bool)": FunctionFragment;
    "offer(uint256,address,uint256,address)": FunctionFragment;
    "offers(uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "sellAllAmount(address,uint256,address,uint256)": FunctionFragment;
    "setAqueductAddress(address)": FunctionFragment;
    "setAqueductDistributionLive(bool)": FunctionFragment;
    "setBuyEnabled(bool)": FunctionFragment;
    "setFeeBPS(uint256)": FunctionFragment;
    "setFeeTo(address)": FunctionFragment;
    "setMatchingEnabled(bool)": FunctionFragment;
    "setMinSell(address,uint256)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "stop()": FunctionFragment;
    "stopped()": FunctionFragment;
    "take(bytes32,uint128)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "AqueductAddress"
      | "AqueductDistributionLive"
      | "_best"
      | "_dust"
      | "_head"
      | "_near"
      | "_rank"
      | "_span"
      | "bump"
      | "buy"
      | "buyAllAmount"
      | "buyEnabled"
      | "cancel"
      | "del_rank"
      | "dustId"
      | "getBestOffer"
      | "getBetterOffer"
      | "getBuyAmount"
      | "getFirstUnsortedOffer"
      | "getMinSell"
      | "getNextUnsortedOffer"
      | "getOffer"
      | "getOfferCount"
      | "getOwner"
      | "getPayAmount"
      | "getTime"
      | "getWorseOffer"
      | "initialize"
      | "initialized"
      | "insert"
      | "isActive"
      | "isClosed"
      | "isOfferSorted"
      | "kill"
      | "last_offer_id"
      | "make"
      | "matchingEnabled"
      | "offer(uint256,address,uint256,address,uint256)"
      | "offer(uint256,address,uint256,address,uint256,bool)"
      | "offer(uint256,address,uint256,address)"
      | "offers"
      | "owner"
      | "sellAllAmount"
      | "setAqueductAddress"
      | "setAqueductDistributionLive"
      | "setBuyEnabled"
      | "setFeeBPS"
      | "setFeeTo"
      | "setMatchingEnabled"
      | "setMinSell"
      | "setOwner"
      | "stop"
      | "stopped"
      | "take"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "AqueductAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "AqueductDistributionLive",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_best",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "_dust",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "_head", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "_near",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "_rank",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "_span",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "bump",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "buy",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "buyAllAmount",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "buyEnabled",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancel",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "del_rank",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "dustId", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getBestOffer",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBetterOffer",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBuyAmount",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getFirstUnsortedOffer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMinSell",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNextUnsortedOffer",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOffer",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOfferCount",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOwner",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPayAmount",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "getTime", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getWorseOffer",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<boolean>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialized",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "insert",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isActive",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "isClosed", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isOfferSorted",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "kill",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "last_offer_id",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "make",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "matchingEnabled",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "offer(uint256,address,uint256,address,uint256)",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "offer(uint256,address,uint256,address,uint256,bool)",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "offer(uint256,address,uint256,address)",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "offers",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "sellAllAmount",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setAqueductAddress",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setAqueductDistributionLive",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBuyEnabled",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeBPS",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMatchingEnabled",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinSell",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "stop", values?: undefined): string;
  encodeFunctionData(functionFragment: "stopped", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "take",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "AqueductAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "AqueductDistributionLive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_best", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_dust", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_head", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_near", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_rank", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_span", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bump", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "buy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "buyAllAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "buyEnabled", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "cancel", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "del_rank", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "dustId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBestOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBetterOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBuyAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFirstUnsortedOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getMinSell", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNextUnsortedOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOffer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getOfferCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getPayAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getTime", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getWorseOffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initialized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "insert", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isActive", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isClosed", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isOfferSorted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "kill", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "last_offer_id",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "make", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "matchingEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "offer(uint256,address,uint256,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "offer(uint256,address,uint256,address,uint256,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "offer(uint256,address,uint256,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "offers", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellAllAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAqueductAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAqueductDistributionLive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBuyEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setFeeBPS", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setFeeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setMatchingEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setMinSell", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stop", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stopped", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "take", data: BytesLike): Result;

  events: {
    "FeeTake(bytes32,bytes32,address,address,address,uint256,uint64)": EventFragment;
    "LogBump(bytes32,bytes32,address,address,address,uint128,uint128,uint64)": EventFragment;
    "LogBuyEnabled(bool)": EventFragment;
    "LogDelete(address,uint256)": EventFragment;
    "LogInsert(address,uint256)": EventFragment;
    "LogInt(string,uint256)": EventFragment;
    "LogItemUpdate(uint256)": EventFragment;
    "LogKill(bytes32,bytes32,address,address,address,uint128,uint128,uint64)": EventFragment;
    "LogMake(bytes32,bytes32,address,address,address,uint128,uint128,uint64)": EventFragment;
    "LogMatch(uint256,uint256)": EventFragment;
    "LogMatchingEnabled(bool)": EventFragment;
    "LogMinSell(address,uint256)": EventFragment;
    "LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
    "LogSortedOffer(uint256)": EventFragment;
    "LogTake(bytes32,bytes32,address,address,address,address,uint128,uint128,uint64)": EventFragment;
    "LogTrade(uint256,address,uint256,address)": EventFragment;
    "LogUnsortedOffer(uint256)": EventFragment;
    "OfferDeleted(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "FeeTake"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogBump"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogBuyEnabled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogDelete"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogInsert"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogInt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogItemUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogKill"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogMake"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogMatch"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogMatchingEnabled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogMinSell"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogNote"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSortedOffer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogTake"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogTrade"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogUnsortedOffer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OfferDeleted"): EventFragment;
}

export interface FeeTakeEventObject {
  id: string;
  pair: string;
  asset: string;
  taker: string;
  feeTo: string;
  feeAmt: BigNumber;
  timestamp: BigNumber;
}
export type FeeTakeEvent = TypedEvent<
  [string, string, string, string, string, BigNumber, BigNumber],
  FeeTakeEventObject
>;

export type FeeTakeEventFilter = TypedEventFilter<FeeTakeEvent>;

export interface LogBumpEventObject {
  id: string;
  pair: string;
  maker: string;
  pay_gem: string;
  buy_gem: string;
  pay_amt: BigNumber;
  buy_amt: BigNumber;
  timestamp: BigNumber;
}
export type LogBumpEvent = TypedEvent<
  [string, string, string, string, string, BigNumber, BigNumber, BigNumber],
  LogBumpEventObject
>;

export type LogBumpEventFilter = TypedEventFilter<LogBumpEvent>;

export interface LogBuyEnabledEventObject {
  isEnabled: boolean;
}
export type LogBuyEnabledEvent = TypedEvent<
  [boolean],
  LogBuyEnabledEventObject
>;

export type LogBuyEnabledEventFilter = TypedEventFilter<LogBuyEnabledEvent>;

export interface LogDeleteEventObject {
  keeper: string;
  id: BigNumber;
}
export type LogDeleteEvent = TypedEvent<
  [string, BigNumber],
  LogDeleteEventObject
>;

export type LogDeleteEventFilter = TypedEventFilter<LogDeleteEvent>;

export interface LogInsertEventObject {
  keeper: string;
  id: BigNumber;
}
export type LogInsertEvent = TypedEvent<
  [string, BigNumber],
  LogInsertEventObject
>;

export type LogInsertEventFilter = TypedEventFilter<LogInsertEvent>;

export interface LogIntEventObject {
  lol: string;
  input: BigNumber;
}
export type LogIntEvent = TypedEvent<[string, BigNumber], LogIntEventObject>;

export type LogIntEventFilter = TypedEventFilter<LogIntEvent>;

export interface LogItemUpdateEventObject {
  id: BigNumber;
}
export type LogItemUpdateEvent = TypedEvent<
  [BigNumber],
  LogItemUpdateEventObject
>;

export type LogItemUpdateEventFilter = TypedEventFilter<LogItemUpdateEvent>;

export interface LogKillEventObject {
  id: string;
  pair: string;
  maker: string;
  pay_gem: string;
  buy_gem: string;
  pay_amt: BigNumber;
  buy_amt: BigNumber;
  timestamp: BigNumber;
}
export type LogKillEvent = TypedEvent<
  [string, string, string, string, string, BigNumber, BigNumber, BigNumber],
  LogKillEventObject
>;

export type LogKillEventFilter = TypedEventFilter<LogKillEvent>;

export interface LogMakeEventObject {
  id: string;
  pair: string;
  maker: string;
  pay_gem: string;
  buy_gem: string;
  pay_amt: BigNumber;
  buy_amt: BigNumber;
  timestamp: BigNumber;
}
export type LogMakeEvent = TypedEvent<
  [string, string, string, string, string, BigNumber, BigNumber, BigNumber],
  LogMakeEventObject
>;

export type LogMakeEventFilter = TypedEventFilter<LogMakeEvent>;

export interface LogMatchEventObject {
  id: BigNumber;
  amount: BigNumber;
}
export type LogMatchEvent = TypedEvent<
  [BigNumber, BigNumber],
  LogMatchEventObject
>;

export type LogMatchEventFilter = TypedEventFilter<LogMatchEvent>;

export interface LogMatchingEnabledEventObject {
  isEnabled: boolean;
}
export type LogMatchingEnabledEvent = TypedEvent<
  [boolean],
  LogMatchingEnabledEventObject
>;

export type LogMatchingEnabledEventFilter =
  TypedEventFilter<LogMatchingEnabledEvent>;

export interface LogMinSellEventObject {
  pay_gem: string;
  min_amount: BigNumber;
}
export type LogMinSellEvent = TypedEvent<
  [string, BigNumber],
  LogMinSellEventObject
>;

export type LogMinSellEventFilter = TypedEventFilter<LogMinSellEvent>;

export interface LogNoteEventObject {
  sig: string;
  guy: string;
  foo: string;
  bar: string;
  wad: BigNumber;
  fax: string;
}
export type LogNoteEvent = TypedEvent<
  [string, string, string, string, BigNumber, string],
  LogNoteEventObject
>;

export type LogNoteEventFilter = TypedEventFilter<LogNoteEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface LogSortedOfferEventObject {
  id: BigNumber;
}
export type LogSortedOfferEvent = TypedEvent<
  [BigNumber],
  LogSortedOfferEventObject
>;

export type LogSortedOfferEventFilter = TypedEventFilter<LogSortedOfferEvent>;

export interface LogTakeEventObject {
  id: string;
  pair: string;
  maker: string;
  pay_gem: string;
  buy_gem: string;
  taker: string;
  take_amt: BigNumber;
  give_amt: BigNumber;
  timestamp: BigNumber;
}
export type LogTakeEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ],
  LogTakeEventObject
>;

export type LogTakeEventFilter = TypedEventFilter<LogTakeEvent>;

export interface LogTradeEventObject {
  pay_amt: BigNumber;
  pay_gem: string;
  buy_amt: BigNumber;
  buy_gem: string;
}
export type LogTradeEvent = TypedEvent<
  [BigNumber, string, BigNumber, string],
  LogTradeEventObject
>;

export type LogTradeEventFilter = TypedEventFilter<LogTradeEvent>;

export interface LogUnsortedOfferEventObject {
  id: BigNumber;
}
export type LogUnsortedOfferEvent = TypedEvent<
  [BigNumber],
  LogUnsortedOfferEventObject
>;

export type LogUnsortedOfferEventFilter =
  TypedEventFilter<LogUnsortedOfferEvent>;

export interface OfferDeletedEventObject {
  id: BigNumber;
}
export type OfferDeletedEvent = TypedEvent<
  [BigNumber],
  OfferDeletedEventObject
>;

export type OfferDeletedEventFilter = TypedEventFilter<OfferDeletedEvent>;

export interface RubiconMarket extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: RubiconMarketInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    AqueductAddress(overrides?: CallOverrides): Promise<[string]>;

    AqueductDistributionLive(overrides?: CallOverrides): Promise<[boolean]>;

    _best(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    _dust(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    _head(overrides?: CallOverrides): Promise<[BigNumber]>;

    _near(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    _rank(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        next: BigNumber;
        prev: BigNumber;
        delb: BigNumber;
      }
    >;

    _span(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    bump(
      id_: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    buy(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    buyAllAmount(
      buy_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      max_fill_amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    buyEnabled(overrides?: CallOverrides): Promise<[boolean]>;

    cancel(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    del_rank(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    dustId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getBestOffer(
      sell_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getBetterOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getBuyAmount(
      buy_gem: PromiseOrValue<string>,
      pay_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { fill_amt: BigNumber }>;

    getFirstUnsortedOffer(overrides?: CallOverrides): Promise<[BigNumber]>;

    getMinSell(
      pay_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getNextUnsortedOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string, BigNumber, string]>;

    getOfferCount(
      sell_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getOwner(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { owner: string }>;

    getPayAmount(
      pay_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { fill_amt: BigNumber }>;

    getTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    getWorseOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    initialize(
      _live: PromiseOrValue<boolean>,
      _feeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialized(overrides?: CallOverrides): Promise<[boolean]>;

    insert(
      id: PromiseOrValue<BigNumberish>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isActive(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { active: boolean }>;

    isClosed(
      overrides?: CallOverrides
    ): Promise<[boolean] & { closed: boolean }>;

    isOfferSorted(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    kill(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    last_offer_id(overrides?: CallOverrides): Promise<[BigNumber]>;

    make(
      pay_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      buy_amt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    matchingEnabled(overrides?: CallOverrides): Promise<[boolean]>;

    "offer(uint256,address,uint256,address,uint256)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "offer(uint256,address,uint256,address,uint256,bool)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      matching: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "offer(uint256,address,uint256,address)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    offers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, BigNumber, string, string, BigNumber] & {
        pay_amt: BigNumber;
        pay_gem: string;
        buy_amt: BigNumber;
        buy_gem: string;
        owner: string;
        timestamp: BigNumber;
      }
    >;

    owner(overrides?: CallOverrides): Promise<[string]>;

    sellAllAmount(
      pay_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      min_fill_amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAqueductAddress(
      _Aqueduct: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAqueductDistributionLive(
      live: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBuyEnabled(
      buyEnabled_: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFeeBPS(
      _newFeeBPS: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFeeTo(
      newFeeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMatchingEnabled(
      matchingEnabled_: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMinSell(
      pay_gem: PromiseOrValue<string>,
      dust: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stop(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stopped(overrides?: CallOverrides): Promise<[boolean]>;

    take(
      id: PromiseOrValue<BytesLike>,
      maxTakeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  AqueductAddress(overrides?: CallOverrides): Promise<string>;

  AqueductDistributionLive(overrides?: CallOverrides): Promise<boolean>;

  _best(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  _dust(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  _head(overrides?: CallOverrides): Promise<BigNumber>;

  _near(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  _rank(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      next: BigNumber;
      prev: BigNumber;
      delb: BigNumber;
    }
  >;

  _span(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  bump(
    id_: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  buy(
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  buyAllAmount(
    buy_gem: PromiseOrValue<string>,
    buy_amt: PromiseOrValue<BigNumberish>,
    pay_gem: PromiseOrValue<string>,
    max_fill_amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  buyEnabled(overrides?: CallOverrides): Promise<boolean>;

  cancel(
    id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  del_rank(
    id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  dustId(overrides?: CallOverrides): Promise<BigNumber>;

  getBestOffer(
    sell_gem: PromiseOrValue<string>,
    buy_gem: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getBetterOffer(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getBuyAmount(
    buy_gem: PromiseOrValue<string>,
    pay_gem: PromiseOrValue<string>,
    pay_amt: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getFirstUnsortedOffer(overrides?: CallOverrides): Promise<BigNumber>;

  getMinSell(
    pay_gem: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getNextUnsortedOffer(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getOffer(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, string, BigNumber, string]>;

  getOfferCount(
    sell_gem: PromiseOrValue<string>,
    buy_gem: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getOwner(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getPayAmount(
    pay_gem: PromiseOrValue<string>,
    buy_gem: PromiseOrValue<string>,
    buy_amt: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTime(overrides?: CallOverrides): Promise<BigNumber>;

  getWorseOffer(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initialize(
    _live: PromiseOrValue<boolean>,
    _feeTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialized(overrides?: CallOverrides): Promise<boolean>;

  insert(
    id: PromiseOrValue<BigNumberish>,
    pos: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isActive(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isClosed(overrides?: CallOverrides): Promise<boolean>;

  isOfferSorted(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  kill(
    id: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  last_offer_id(overrides?: CallOverrides): Promise<BigNumber>;

  make(
    pay_gem: PromiseOrValue<string>,
    buy_gem: PromiseOrValue<string>,
    pay_amt: PromiseOrValue<BigNumberish>,
    buy_amt: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  matchingEnabled(overrides?: CallOverrides): Promise<boolean>;

  "offer(uint256,address,uint256,address,uint256)"(
    pay_amt: PromiseOrValue<BigNumberish>,
    pay_gem: PromiseOrValue<string>,
    buy_amt: PromiseOrValue<BigNumberish>,
    buy_gem: PromiseOrValue<string>,
    pos: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "offer(uint256,address,uint256,address,uint256,bool)"(
    pay_amt: PromiseOrValue<BigNumberish>,
    pay_gem: PromiseOrValue<string>,
    buy_amt: PromiseOrValue<BigNumberish>,
    buy_gem: PromiseOrValue<string>,
    pos: PromiseOrValue<BigNumberish>,
    matching: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "offer(uint256,address,uint256,address)"(
    pay_amt: PromiseOrValue<BigNumberish>,
    pay_gem: PromiseOrValue<string>,
    buy_amt: PromiseOrValue<BigNumberish>,
    buy_gem: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  offers(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string, BigNumber, string, string, BigNumber] & {
      pay_amt: BigNumber;
      pay_gem: string;
      buy_amt: BigNumber;
      buy_gem: string;
      owner: string;
      timestamp: BigNumber;
    }
  >;

  owner(overrides?: CallOverrides): Promise<string>;

  sellAllAmount(
    pay_gem: PromiseOrValue<string>,
    pay_amt: PromiseOrValue<BigNumberish>,
    buy_gem: PromiseOrValue<string>,
    min_fill_amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAqueductAddress(
    _Aqueduct: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAqueductDistributionLive(
    live: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBuyEnabled(
    buyEnabled_: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFeeBPS(
    _newFeeBPS: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFeeTo(
    newFeeTo: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMatchingEnabled(
    matchingEnabled_: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMinSell(
    pay_gem: PromiseOrValue<string>,
    dust: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stop(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stopped(overrides?: CallOverrides): Promise<boolean>;

  take(
    id: PromiseOrValue<BytesLike>,
    maxTakeAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    AqueductAddress(overrides?: CallOverrides): Promise<string>;

    AqueductDistributionLive(overrides?: CallOverrides): Promise<boolean>;

    _best(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _dust(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _head(overrides?: CallOverrides): Promise<BigNumber>;

    _near(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _rank(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        next: BigNumber;
        prev: BigNumber;
        delb: BigNumber;
      }
    >;

    _span(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bump(
      id_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    buy(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    buyAllAmount(
      buy_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      max_fill_amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    buyEnabled(overrides?: CallOverrides): Promise<boolean>;

    cancel(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    del_rank(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    dustId(overrides?: CallOverrides): Promise<BigNumber>;

    getBestOffer(
      sell_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBetterOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBuyAmount(
      buy_gem: PromiseOrValue<string>,
      pay_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFirstUnsortedOffer(overrides?: CallOverrides): Promise<BigNumber>;

    getMinSell(
      pay_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNextUnsortedOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string, BigNumber, string]>;

    getOfferCount(
      sell_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOwner(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getPayAmount(
      pay_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTime(overrides?: CallOverrides): Promise<BigNumber>;

    getWorseOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      _live: PromiseOrValue<boolean>,
      _feeTo: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    initialized(overrides?: CallOverrides): Promise<boolean>;

    insert(
      id: PromiseOrValue<BigNumberish>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isActive(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isClosed(overrides?: CallOverrides): Promise<boolean>;

    isOfferSorted(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    kill(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    last_offer_id(overrides?: CallOverrides): Promise<BigNumber>;

    make(
      pay_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      buy_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    matchingEnabled(overrides?: CallOverrides): Promise<boolean>;

    "offer(uint256,address,uint256,address,uint256)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "offer(uint256,address,uint256,address,uint256,bool)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      matching: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "offer(uint256,address,uint256,address)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    offers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, BigNumber, string, string, BigNumber] & {
        pay_amt: BigNumber;
        pay_gem: string;
        buy_amt: BigNumber;
        buy_gem: string;
        owner: string;
        timestamp: BigNumber;
      }
    >;

    owner(overrides?: CallOverrides): Promise<string>;

    sellAllAmount(
      pay_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      min_fill_amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setAqueductAddress(
      _Aqueduct: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setAqueductDistributionLive(
      live: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setBuyEnabled(
      buyEnabled_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setFeeBPS(
      _newFeeBPS: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setFeeTo(
      newFeeTo: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setMatchingEnabled(
      matchingEnabled_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setMinSell(
      pay_gem: PromiseOrValue<string>,
      dust: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    stop(overrides?: CallOverrides): Promise<void>;

    stopped(overrides?: CallOverrides): Promise<boolean>;

    take(
      id: PromiseOrValue<BytesLike>,
      maxTakeAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "FeeTake(bytes32,bytes32,address,address,address,uint256,uint64)"(
      id?: PromiseOrValue<BytesLike> | null,
      pair?: PromiseOrValue<BytesLike> | null,
      asset?: null,
      taker?: PromiseOrValue<string> | null,
      feeTo?: null,
      feeAmt?: null,
      timestamp?: null
    ): FeeTakeEventFilter;
    FeeTake(
      id?: PromiseOrValue<BytesLike> | null,
      pair?: PromiseOrValue<BytesLike> | null,
      asset?: null,
      taker?: PromiseOrValue<string> | null,
      feeTo?: null,
      feeAmt?: null,
      timestamp?: null
    ): FeeTakeEventFilter;

    "LogBump(bytes32,bytes32,address,address,address,uint128,uint128,uint64)"(
      id?: PromiseOrValue<BytesLike> | null,
      pair?: PromiseOrValue<BytesLike> | null,
      maker?: PromiseOrValue<string> | null,
      pay_gem?: null,
      buy_gem?: null,
      pay_amt?: null,
      buy_amt?: null,
      timestamp?: null
    ): LogBumpEventFilter;
    LogBump(
      id?: PromiseOrValue<BytesLike> | null,
      pair?: PromiseOrValue<BytesLike> | null,
      maker?: PromiseOrValue<string> | null,
      pay_gem?: null,
      buy_gem?: null,
      pay_amt?: null,
      buy_amt?: null,
      timestamp?: null
    ): LogBumpEventFilter;

    "LogBuyEnabled(bool)"(isEnabled?: null): LogBuyEnabledEventFilter;
    LogBuyEnabled(isEnabled?: null): LogBuyEnabledEventFilter;

    "LogDelete(address,uint256)"(
      keeper?: null,
      id?: null
    ): LogDeleteEventFilter;
    LogDelete(keeper?: null, id?: null): LogDeleteEventFilter;

    "LogInsert(address,uint256)"(
      keeper?: null,
      id?: null
    ): LogInsertEventFilter;
    LogInsert(keeper?: null, id?: null): LogInsertEventFilter;

    "LogInt(string,uint256)"(lol?: null, input?: null): LogIntEventFilter;
    LogInt(lol?: null, input?: null): LogIntEventFilter;

    "LogItemUpdate(uint256)"(id?: null): LogItemUpdateEventFilter;
    LogItemUpdate(id?: null): LogItemUpdateEventFilter;

    "LogKill(bytes32,bytes32,address,address,address,uint128,uint128,uint64)"(
      id?: PromiseOrValue<BytesLike> | null,
      pair?: PromiseOrValue<BytesLike> | null,
      maker?: PromiseOrValue<string> | null,
      pay_gem?: null,
      buy_gem?: null,
      pay_amt?: null,
      buy_amt?: null,
      timestamp?: null
    ): LogKillEventFilter;
    LogKill(
      id?: PromiseOrValue<BytesLike> | null,
      pair?: PromiseOrValue<BytesLike> | null,
      maker?: PromiseOrValue<string> | null,
      pay_gem?: null,
      buy_gem?: null,
      pay_amt?: null,
      buy_amt?: null,
      timestamp?: null
    ): LogKillEventFilter;

    "LogMake(bytes32,bytes32,address,address,address,uint128,uint128,uint64)"(
      id?: PromiseOrValue<BytesLike> | null,
      pair?: PromiseOrValue<BytesLike> | null,
      maker?: PromiseOrValue<string> | null,
      pay_gem?: null,
      buy_gem?: null,
      pay_amt?: null,
      buy_amt?: null,
      timestamp?: null
    ): LogMakeEventFilter;
    LogMake(
      id?: PromiseOrValue<BytesLike> | null,
      pair?: PromiseOrValue<BytesLike> | null,
      maker?: PromiseOrValue<string> | null,
      pay_gem?: null,
      buy_gem?: null,
      pay_amt?: null,
      buy_amt?: null,
      timestamp?: null
    ): LogMakeEventFilter;

    "LogMatch(uint256,uint256)"(id?: null, amount?: null): LogMatchEventFilter;
    LogMatch(id?: null, amount?: null): LogMatchEventFilter;

    "LogMatchingEnabled(bool)"(isEnabled?: null): LogMatchingEnabledEventFilter;
    LogMatchingEnabled(isEnabled?: null): LogMatchingEnabledEventFilter;

    "LogMinSell(address,uint256)"(
      pay_gem?: null,
      min_amount?: null
    ): LogMinSellEventFilter;
    LogMinSell(pay_gem?: null, min_amount?: null): LogMinSellEventFilter;

    "LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)"(
      sig?: PromiseOrValue<BytesLike> | null,
      guy?: PromiseOrValue<string> | null,
      foo?: PromiseOrValue<BytesLike> | null,
      bar?: PromiseOrValue<BytesLike> | null,
      wad?: null,
      fax?: null
    ): LogNoteEventFilter;
    LogNote(
      sig?: PromiseOrValue<BytesLike> | null,
      guy?: PromiseOrValue<string> | null,
      foo?: PromiseOrValue<BytesLike> | null,
      bar?: PromiseOrValue<BytesLike> | null,
      wad?: null,
      fax?: null
    ): LogNoteEventFilter;

    "LogSetAuthority(address)"(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(
      owner?: PromiseOrValue<string> | null
    ): LogSetOwnerEventFilter;
    LogSetOwner(owner?: PromiseOrValue<string> | null): LogSetOwnerEventFilter;

    "LogSortedOffer(uint256)"(id?: null): LogSortedOfferEventFilter;
    LogSortedOffer(id?: null): LogSortedOfferEventFilter;

    "LogTake(bytes32,bytes32,address,address,address,address,uint128,uint128,uint64)"(
      id?: null,
      pair?: PromiseOrValue<BytesLike> | null,
      maker?: PromiseOrValue<string> | null,
      pay_gem?: null,
      buy_gem?: null,
      taker?: PromiseOrValue<string> | null,
      take_amt?: null,
      give_amt?: null,
      timestamp?: null
    ): LogTakeEventFilter;
    LogTake(
      id?: null,
      pair?: PromiseOrValue<BytesLike> | null,
      maker?: PromiseOrValue<string> | null,
      pay_gem?: null,
      buy_gem?: null,
      taker?: PromiseOrValue<string> | null,
      take_amt?: null,
      give_amt?: null,
      timestamp?: null
    ): LogTakeEventFilter;

    "LogTrade(uint256,address,uint256,address)"(
      pay_amt?: null,
      pay_gem?: PromiseOrValue<string> | null,
      buy_amt?: null,
      buy_gem?: PromiseOrValue<string> | null
    ): LogTradeEventFilter;
    LogTrade(
      pay_amt?: null,
      pay_gem?: PromiseOrValue<string> | null,
      buy_amt?: null,
      buy_gem?: PromiseOrValue<string> | null
    ): LogTradeEventFilter;

    "LogUnsortedOffer(uint256)"(id?: null): LogUnsortedOfferEventFilter;
    LogUnsortedOffer(id?: null): LogUnsortedOfferEventFilter;

    "OfferDeleted(uint256)"(id?: null): OfferDeletedEventFilter;
    OfferDeleted(id?: null): OfferDeletedEventFilter;
  };

  estimateGas: {
    AqueductAddress(overrides?: CallOverrides): Promise<BigNumber>;

    AqueductDistributionLive(overrides?: CallOverrides): Promise<BigNumber>;

    _best(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _dust(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _head(overrides?: CallOverrides): Promise<BigNumber>;

    _near(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _rank(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    _span(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bump(
      id_: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    buy(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    buyAllAmount(
      buy_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      max_fill_amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    buyEnabled(overrides?: CallOverrides): Promise<BigNumber>;

    cancel(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    del_rank(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    dustId(overrides?: CallOverrides): Promise<BigNumber>;

    getBestOffer(
      sell_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBetterOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBuyAmount(
      buy_gem: PromiseOrValue<string>,
      pay_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFirstUnsortedOffer(overrides?: CallOverrides): Promise<BigNumber>;

    getMinSell(
      pay_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNextUnsortedOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOfferCount(
      sell_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOwner(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPayAmount(
      pay_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTime(overrides?: CallOverrides): Promise<BigNumber>;

    getWorseOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      _live: PromiseOrValue<boolean>,
      _feeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialized(overrides?: CallOverrides): Promise<BigNumber>;

    insert(
      id: PromiseOrValue<BigNumberish>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isActive(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isClosed(overrides?: CallOverrides): Promise<BigNumber>;

    isOfferSorted(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    kill(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    last_offer_id(overrides?: CallOverrides): Promise<BigNumber>;

    make(
      pay_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      buy_amt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    matchingEnabled(overrides?: CallOverrides): Promise<BigNumber>;

    "offer(uint256,address,uint256,address,uint256)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "offer(uint256,address,uint256,address,uint256,bool)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      matching: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "offer(uint256,address,uint256,address)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    offers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    sellAllAmount(
      pay_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      min_fill_amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAqueductAddress(
      _Aqueduct: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAqueductDistributionLive(
      live: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBuyEnabled(
      buyEnabled_: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFeeBPS(
      _newFeeBPS: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFeeTo(
      newFeeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMatchingEnabled(
      matchingEnabled_: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMinSell(
      pay_gem: PromiseOrValue<string>,
      dust: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stop(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stopped(overrides?: CallOverrides): Promise<BigNumber>;

    take(
      id: PromiseOrValue<BytesLike>,
      maxTakeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    AqueductAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    AqueductDistributionLive(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _best(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _dust(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _head(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _near(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _rank(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    _span(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bump(
      id_: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    buy(
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    buyAllAmount(
      buy_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      max_fill_amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    buyEnabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cancel(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    del_rank(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    dustId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBestOffer(
      sell_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBetterOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBuyAmount(
      buy_gem: PromiseOrValue<string>,
      pay_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFirstUnsortedOffer(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMinSell(
      pay_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNextUnsortedOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOfferCount(
      sell_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOwner(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPayAmount(
      pay_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getWorseOffer(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      _live: PromiseOrValue<boolean>,
      _feeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialized(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    insert(
      id: PromiseOrValue<BigNumberish>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isActive(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isClosed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isOfferSorted(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    kill(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    last_offer_id(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    make(
      pay_gem: PromiseOrValue<string>,
      buy_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      buy_amt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    matchingEnabled(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "offer(uint256,address,uint256,address,uint256)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "offer(uint256,address,uint256,address,uint256,bool)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      pos: PromiseOrValue<BigNumberish>,
      matching: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "offer(uint256,address,uint256,address)"(
      pay_amt: PromiseOrValue<BigNumberish>,
      pay_gem: PromiseOrValue<string>,
      buy_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    offers(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sellAllAmount(
      pay_gem: PromiseOrValue<string>,
      pay_amt: PromiseOrValue<BigNumberish>,
      buy_gem: PromiseOrValue<string>,
      min_fill_amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAqueductAddress(
      _Aqueduct: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAqueductDistributionLive(
      live: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBuyEnabled(
      buyEnabled_: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFeeBPS(
      _newFeeBPS: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFeeTo(
      newFeeTo: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMatchingEnabled(
      matchingEnabled_: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMinSell(
      pay_gem: PromiseOrValue<string>,
      dust: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stop(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stopped(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    take(
      id: PromiseOrValue<BytesLike>,
      maxTakeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
